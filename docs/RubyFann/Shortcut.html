<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class RubyFann::Shortcut - Ruby FANN Gem documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/navigation.js" defer></script>
<script src="../js/search.js" defer></script>
<script src="../js/search_index.js" defer></script>
<script src="../js/searcher.js" defer></script>
<script src="../js/darkfish.js" defer></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link">Object
</div>

    
    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-i-cascadetrain_on_data">#cascadetrain_on_data</a>
    <li ><a href="#method-i-get_MSE">#get_MSE</a>
    <li ><a href="#method-i-get_activation_function">#get_activation_function</a>
    <li ><a href="#method-i-get_activation_steepness">#get_activation_steepness</a>
    <li ><a href="#method-i-get_bias_array">#get_bias_array</a>
    <li ><a href="#method-i-get_bit_fail">#get_bit_fail</a>
    <li ><a href="#method-i-get_bit_fail_limit">#get_bit_fail_limit</a>
    <li ><a href="#method-i-get_cascade_activation_functions">#get_cascade_activation_functions</a>
    <li ><a href="#method-i-get_cascade_activation_functions_count">#get_cascade_activation_functions_count</a>
    <li ><a href="#method-i-get_cascade_activation_steepnesses">#get_cascade_activation_steepnesses</a>
    <li ><a href="#method-i-get_cascade_activation_steepnesses_count">#get_cascade_activation_steepnesses_count</a>
    <li ><a href="#method-i-get_cascade_candidate_change_fraction">#get_cascade_candidate_change_fraction</a>
    <li ><a href="#method-i-get_cascade_candidate_limit">#get_cascade_candidate_limit</a>
    <li ><a href="#method-i-get_cascade_candidate_stagnation_epochs">#get_cascade_candidate_stagnation_epochs</a>
    <li ><a href="#method-i-get_cascade_max_cand_epochs">#get_cascade_max_cand_epochs</a>
    <li ><a href="#method-i-get_cascade_max_out_epochs">#get_cascade_max_out_epochs</a>
    <li ><a href="#method-i-get_cascade_num_candidate_groups">#get_cascade_num_candidate_groups</a>
    <li ><a href="#method-i-get_cascade_num_candidates">#get_cascade_num_candidates</a>
    <li ><a href="#method-i-get_cascade_output_change_fraction">#get_cascade_output_change_fraction</a>
    <li ><a href="#method-i-get_cascade_output_stagnation_epochs">#get_cascade_output_stagnation_epochs</a>
    <li ><a href="#method-i-get_cascade_weight_multiplier">#get_cascade_weight_multiplier</a>
    <li ><a href="#method-i-get_connection_rate">#get_connection_rate</a>
    <li ><a href="#method-i-get_layer_array">#get_layer_array</a>
    <li ><a href="#method-i-get_learning_momentum">#get_learning_momentum</a>
    <li ><a href="#method-i-get_learning_rate">#get_learning_rate</a>
    <li ><a href="#method-i-get_network_type">#get_network_type</a>
    <li ><a href="#method-i-get_neurons">#get_neurons</a>
    <li ><a href="#method-i-get_num_input">#get_num_input</a>
    <li ><a href="#method-i-get_num_layers">#get_num_layers</a>
    <li ><a href="#method-i-get_num_output">#get_num_output</a>
    <li ><a href="#method-i-get_quickprop_decay">#get_quickprop_decay</a>
    <li ><a href="#method-i-get_quickprop_mu">#get_quickprop_mu</a>
    <li ><a href="#method-i-get_rprop_decrease_factor">#get_rprop_decrease_factor</a>
    <li ><a href="#method-i-get_rprop_delta_max">#get_rprop_delta_max</a>
    <li ><a href="#method-i-get_rprop_delta_min">#get_rprop_delta_min</a>
    <li ><a href="#method-i-get_rprop_delta_zero">#get_rprop_delta_zero</a>
    <li ><a href="#method-i-get_rprop_increase_factor">#get_rprop_increase_factor</a>
    <li ><a href="#method-i-get_total_connections">#get_total_connections</a>
    <li ><a href="#method-i-get_total_neurons">#get_total_neurons</a>
    <li ><a href="#method-i-get_train_error_function">#get_train_error_function</a>
    <li ><a href="#method-i-get_train_stop_function">#get_train_stop_function</a>
    <li ><a href="#method-i-get_training_algorithm">#get_training_algorithm</a>
    <li ><a href="#method-i-init_weights">#init_weights</a>
    <li ><a href="#method-i-print_connections">#print_connections</a>
    <li ><a href="#method-i-print_parameters">#print_parameters</a>
    <li ><a href="#method-i-randomize_weights">#randomize_weights</a>
    <li ><a href="#method-i-reset_MSE">#reset_MSE</a>
    <li ><a href="#method-i-run">#run</a>
    <li ><a href="#method-i-save">#save</a>
    <li ><a href="#method-i-set_activation_function">#set_activation_function</a>
    <li ><a href="#method-i-set_activation_function_hidden">#set_activation_function_hidden</a>
    <li ><a href="#method-i-set_activation_function_layer">#set_activation_function_layer</a>
    <li ><a href="#method-i-set_activation_function_output">#set_activation_function_output</a>
    <li ><a href="#method-i-set_activation_steepness">#set_activation_steepness</a>
    <li ><a href="#method-i-set_activation_steepness_hidden">#set_activation_steepness_hidden</a>
    <li ><a href="#method-i-set_activation_steepness_layer">#set_activation_steepness_layer</a>
    <li ><a href="#method-i-set_activation_steepness_output">#set_activation_steepness_output</a>
    <li ><a href="#method-i-set_bit_fail_limit">#set_bit_fail_limit</a>
    <li ><a href="#method-i-set_cascade_activation_functions">#set_cascade_activation_functions</a>
    <li ><a href="#method-i-set_cascade_activation_steepnesses">#set_cascade_activation_steepnesses</a>
    <li ><a href="#method-i-set_cascade_candidate_change_fraction">#set_cascade_candidate_change_fraction</a>
    <li ><a href="#method-i-set_cascade_candidate_limit">#set_cascade_candidate_limit</a>
    <li ><a href="#method-i-set_cascade_candidate_stagnation_epochs">#set_cascade_candidate_stagnation_epochs</a>
    <li ><a href="#method-i-set_cascade_max_cand_epochs">#set_cascade_max_cand_epochs</a>
    <li ><a href="#method-i-set_cascade_max_out_epochs">#set_cascade_max_out_epochs</a>
    <li ><a href="#method-i-set_cascade_num_candidate_groups">#set_cascade_num_candidate_groups</a>
    <li ><a href="#method-i-set_cascade_output_change_fraction">#set_cascade_output_change_fraction</a>
    <li ><a href="#method-i-set_cascade_output_stagnation_epochs">#set_cascade_output_stagnation_epochs</a>
    <li ><a href="#method-i-set_cascade_weight_multiplier">#set_cascade_weight_multiplier</a>
    <li ><a href="#method-i-set_learning_momentum">#set_learning_momentum</a>
    <li ><a href="#method-i-set_learning_rate">#set_learning_rate</a>
    <li ><a href="#method-i-set_quickprop_decay">#set_quickprop_decay</a>
    <li ><a href="#method-i-set_quickprop_mu">#set_quickprop_mu</a>
    <li ><a href="#method-i-set_rprop_decrease_factor">#set_rprop_decrease_factor</a>
    <li ><a href="#method-i-set_rprop_delta_max">#set_rprop_delta_max</a>
    <li ><a href="#method-i-set_rprop_delta_min">#set_rprop_delta_min</a>
    <li ><a href="#method-i-set_rprop_delta_zero">#set_rprop_delta_zero</a>
    <li ><a href="#method-i-set_rprop_increase_factor">#set_rprop_increase_factor</a>
    <li ><a href="#method-i-set_train_error_function">#set_train_error_function</a>
    <li ><a href="#method-i-set_train_stop_function">#set_train_stop_function</a>
    <li ><a href="#method-i-set_training_algorithm">#set_training_algorithm</a>
    <li ><a href="#method-i-test_data">#test_data</a>
    <li ><a href="#method-i-train">#train</a>
    <li ><a href="#method-i-train_epoch">#train_epoch</a>
    <li ><a href="#method-i-train_on_data">#train_on_data</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-RubyFann::Shortcut">
  <h1 id="class-RubyFann::Shortcut" class="class">
    class RubyFann::Shortcut
  </h1>

  <section class="description">
    
  </section>

  <section id="5Buntitled-5D" class="documentation-section">





     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-new" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              new(hash) &rarr; new ruby-fann neural network object
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Initialization routine for both standard, shortcut &amp; filename forms of FANN:</p>

<p><a href="Standard.html"><code>Standard</code></a> Initialization:</p>

<pre class="ruby"><span class="ruby-constant">RubyFann</span><span class="ruby-operator">::</span><span class="ruby-constant">Standard</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:num_inputs</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">1</span>, <span class="ruby-value">:hidden_neurons</span><span class="ruby-operator">=&gt;</span>[<span class="ruby-value">3</span>, <span class="ruby-value">4</span>, <span class="ruby-value">3</span>, <span class="ruby-value">4</span>], <span class="ruby-value">:num_outputs</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">1</span>)
</pre>

<p><a href="Shortcut.html"><code>Shortcut</code></a> Initialization (e.g., for use in cascade training):</p>

<pre class="ruby"><span class="ruby-constant">RubyFann</span><span class="ruby-operator">::</span><span class="ruby-constant">Shortcut</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:num_inputs</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">5</span>, <span class="ruby-value">:num_outputs</span><span class="ruby-operator">=&gt;</span><span class="ruby-value">1</span>)
</pre>

<p>File Initialization</p>

<pre class="ruby"><span class="ruby-constant">RubyFann</span><span class="ruby-operator">::</span><span class="ruby-constant">Standard</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">:filename</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;xor_float.net&#39;</span>)
</pre>

          <div class="method-source-code" id="new-source">
            <pre>static VALUE fann_initialize(VALUE self, VALUE hash)
{
    // Get args:
    VALUE filename = rb_hash_aref(hash, ID2SYM(rb_intern(&quot;filename&quot;)));
    VALUE num_inputs = rb_hash_aref(hash, ID2SYM(rb_intern(&quot;num_inputs&quot;)));
    VALUE num_outputs = rb_hash_aref(hash, ID2SYM(rb_intern(&quot;num_outputs&quot;)));
    VALUE hidden_neurons = rb_hash_aref(hash, ID2SYM(rb_intern(&quot;hidden_neurons&quot;)));
    // printf(&quot;initializing\n\n\n&quot;);
    struct fann *ann;
    if (TYPE(filename) == T_STRING)
    {
        // Initialize with file:
        // train_data = fann_read_train_from_file(StringValuePtr(filename));
        // DATA_PTR(self) = train_data;
        ann = fann_create_from_file(StringValuePtr(filename));
        // printf(&quot;Created RubyFann::Standard [%d] from file [%s].\n&quot;, ann, StringValuePtr(filename));
    }
    else if (rb_obj_is_kind_of(self, m_rb_fann_shortcut_class))
    {
        // Initialize as shortcut, suitable for cascade training:
        // ann = fann_create_shortcut_array(num_layers, layers);
        Check_Type(num_inputs, T_FIXNUM);
        Check_Type(num_outputs, T_FIXNUM);

        ann = fann_create_shortcut(2, NUM2INT(num_inputs), NUM2INT(num_outputs));
        // printf(&quot;Created RubyFann::Shortcut [%d].\n&quot;, ann);
    }
    else
    {
        // Initialize as standard:
        Check_Type(num_inputs, T_FIXNUM);
        Check_Type(hidden_neurons, T_ARRAY);
        Check_Type(num_outputs, T_FIXNUM);

        // Initialize layers:
        unsigned int num_layers = RARRAY_LEN(hidden_neurons) + 2;
        unsigned int layers[num_layers];

        // Input:
        layers[0] = NUM2INT(num_inputs);
        // Output:
        layers[num_layers - 1] = NUM2INT(num_outputs);
        // Hidden:
        unsigned int i;
        for (i = 1; i &lt;= num_layers - 2; i++)
        {
            layers[i] = NUM2INT(RARRAY_PTR(hidden_neurons)[i - 1]);
        }
        ann = fann_create_standard_array(num_layers, layers);
    }

    DATA_PTR(self) = ann;

    // printf(&quot;Checking for callback...&quot;);

    // int callback = rb_protect(invoke_training_callback, (self), &amp;status);
    //  VALUE callback = rb_funcall(DATA_PTR(self), &quot;training_callback&quot;, 0);
    if (rb_respond_to(self, rb_intern(&quot;training_callback&quot;)))
    {
        fann_set_callback(ann, &amp;fann_training_callback);
        fann_set_user_data(ann, self);
        // printf(&quot;found(%d).\n&quot;, ann-&gt;callback);
    }
    else
    {
        // printf(&quot;none found.\n&quot;);
    }

    return (VALUE)ann;
}</pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-cascadetrain_on_data" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              cascadetrain_on_data(train_data, max_neurons, neurons_between_reports, desired_error)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Perform cascade training with training data created with <a href="TrainData.html#method-c-new"><code>RubyFann::TrainData.new</code></a></p>

<pre>max_epochs - The maximum number of neurons in trained network
neurons_between_reports - The number of neurons between printing a status report to stdout.
desired_error - The desired &lt;get_MSE&gt; or &lt;get_bit_fail&gt;, depending on which stop function
is chosen by &lt;set_train_stop_function&gt;.</pre>

          <div class="method-source-code" id="cascadetrain_on_data-source">
            <pre>static VALUE cascadetrain_on_data(VALUE self, VALUE train_data, VALUE max_neurons, VALUE neurons_between_reports, VALUE desired_error)
{
    Check_Type(train_data, T_DATA);
    Check_Type(max_neurons, T_FIXNUM);
    Check_Type(neurons_between_reports, T_FIXNUM);
    Check_Type(desired_error, T_FLOAT);

    struct fann *f;
    struct fann_train_data *t;
    Data_Get_Struct(self, struct fann, f);
    Data_Get_Struct(train_data, struct fann_train_data, t);

    unsigned int fann_max_neurons = NUM2INT(max_neurons);
    unsigned int fann_neurons_between_reports = NUM2INT(neurons_between_reports);
    float fann_desired_error = NUM2DBL(desired_error);

    fann_cascadetrain_on_data(f, t, fann_max_neurons, fann_neurons_between_reports, fann_desired_error);
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_MSE" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_MSE</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Reads the mean square error from the network.</p>

          <div class="method-source-code" id="get_MSE-source">
            <pre>static VALUE get_MSE(VALUE self)
{
    RETURN_FANN_DBL(fann_get_MSE);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_activation_function" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              get_activation_function(layer) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get the activation function for neuron number <strong>neuron</strong> in layer number <strong>layer</strong>, counting the input layer as layer 0.</p>

<p>It is not possible to get activation functions for the neurons in the input layer.</p>

          <div class="method-source-code" id="get_activation_function-source">
            <pre>static VALUE get_activation_function(VALUE self, VALUE layer, VALUE neuron)
{
    Check_Type(layer, T_FIXNUM);
    Check_Type(neuron, T_FIXNUM);
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_type val = fann_get_activation_function(f, NUM2INT(layer), NUM2INT(neuron));
    return activation_function_to_sym(val);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_activation_steepness" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              get_activation_steepness(layer, neuron) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get the activation steepness for neuron number neuron in layer number layer, counting the input layer as layer 0.</p>

          <div class="method-source-code" id="get_activation_steepness-source">
            <pre>static VALUE get_activation_steepness(VALUE self, VALUE layer, VALUE neuron)
{
    Check_Type(layer, T_FIXNUM);
    Check_Type(neuron, T_FIXNUM);
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_type val = fann_get_activation_steepness(f, NUM2INT(layer), NUM2INT(neuron));
    return rb_float_new(val);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_bias_array" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_bias_array</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Return array of bias(es)</p>

          <div class="method-source-code" id="get_bias_array-source">
            <pre>static VALUE get_bias_array(VALUE self)
{
    struct fann *f;
    unsigned int num_layers;
    Data_Get_Struct(self, struct fann, f);
    num_layers = fann_get_num_layers(f);
    unsigned int layers[num_layers];
    fann_get_bias_array(f, layers);

    // Create ruby array &amp; set outputs:
    VALUE arr;
    arr = rb_ary_new();
    unsigned int i;
    for (i = 0; i &lt; num_layers; i++)
    {
        rb_ary_push(arr, INT2NUM(layers[i]));
    }

    return arr;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_bit_fail" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_bit_fail</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <pre class="ruby"><span class="ruby-constant">The</span> <span class="ruby-identifier">number</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">fail</span> <span class="ruby-identifier">bits</span>; <span class="ruby-identifier">means</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">number</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">output</span> <span class="ruby-identifier">neurons</span> <span class="ruby-identifier">which</span> <span class="ruby-identifier">differ</span> <span class="ruby-identifier">more</span>
</pre>

<p>than the bit fail limit (see &lt;fann_get_bit_fail_limit&gt;, &lt;fann_set_bit_fail_limit&gt;). The bits are counted in all of the training data, so this number can be higher than the number of training data.</p>

          <div class="method-source-code" id="get_bit_fail-source">
            <pre>static VALUE get_bit_fail(VALUE self)
{
    RETURN_FANN_INT(fann_get_bit_fail);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_bit_fail_limit" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_bit_fail_limit</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the bit fail limit used during training.</p>

          <div class="method-source-code" id="get_bit_fail_limit-source">
            <pre>static VALUE get_bit_fail_limit(VALUE self)
{
    RETURN_FANN_DBL(fann_get_bit_fail_limit);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_activation_functions" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_activation_functions</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The cascade activation functions is an array of the different activation functions used by</p>

<pre class="ruby"><span class="ruby-identifier">the</span> <span class="ruby-identifier">candidates</span>.  <span class="ruby-constant">The</span> <span class="ruby-identifier">default</span> <span class="ruby-identifier">is</span> [<span class="ruby-value">:sigmoid</span>, <span class="ruby-value">:sigmoid_symmetric</span>, <span class="ruby-value">:gaussian</span>, <span class="ruby-value">:gaussian_symmetric</span>, <span class="ruby-value">:elliot</span>, <span class="ruby-value">:elliot_symmetric</span>]
</pre>

          <div class="method-source-code" id="get_cascade_activation_functions-source">
            <pre>static VALUE get_cascade_activation_functions(VALUE self)
{
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    unsigned int cnt = fann_get_cascade_activation_functions_count(f);
    enum fann_activationfunc_enum *fann_functions = fann_get_cascade_activation_functions(f);

    // Create ruby array &amp; set outputs:
    VALUE arr;
    arr = rb_ary_new();
    unsigned int i;
    for (i = 0; i &lt; cnt; i++)
    {
        rb_ary_push(arr, activation_function_to_sym(fann_functions[i]));
    }

    return arr;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_activation_functions_count" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_activation_functions_count</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The number of activation functions in the &lt;get_cascade_activation_functions&gt; array</p>

          <div class="method-source-code" id="get_cascade_activation_functions_count-source">
            <pre>static VALUE get_cascade_activation_functions_count(VALUE self)
{
    RETURN_FANN_UINT(fann_get_cascade_activation_functions_count);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_activation_steepnesses" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_activation_steepnesses</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The cascade activation steepnesses array is an array of the different activation functions used by</p>

<pre>the candidates.</pre>

          <div class="method-source-code" id="get_cascade_activation_steepnesses-source">
            <pre>static VALUE get_cascade_activation_steepnesses(VALUE self)
{
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_type *fann_steepnesses = fann_get_cascade_activation_steepnesses(f);
    unsigned int cnt = fann_get_cascade_activation_steepnesses_count(f);

    // Create ruby array &amp; set outputs:
    VALUE arr;
    arr = rb_ary_new();
    unsigned int i;
    for (i = 0; i &lt; cnt; i++)
    {
        rb_ary_push(arr, rb_float_new(fann_steepnesses[i]));
    }

    return arr;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_activation_steepnesses_count" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_activation_steepnesses_count</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The number of activation steepnesses in the &lt;get_cascade_activation_functions&gt; array.</p>

          <div class="method-source-code" id="get_cascade_activation_steepnesses_count-source">
            <pre>static VALUE get_cascade_activation_steepnesses_count(VALUE self)
{
    RETURN_FANN_UINT(fann_get_cascade_activation_steepnesses_count);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_candidate_change_fraction" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_candidate_change_fraction</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The cascade candidate change fraction is a number between 0 and 1</p>

          <div class="method-source-code" id="get_cascade_candidate_change_fraction-source">
            <pre>static VALUE get_cascade_candidate_change_fraction(VALUE self)
{
    RETURN_FANN_FLT(fann_get_cascade_candidate_change_fraction);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_candidate_limit" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_candidate_limit</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The candidate limit is a limit for how much the candidate neuron may be trained.</p>

<pre>The limit is a limit on the proportion between the MSE and candidate score.</pre>

          <div class="method-source-code" id="get_cascade_candidate_limit-source">
            <pre>static VALUE get_cascade_candidate_limit(VALUE self)
{
    RETURN_FANN_DBL(fann_get_cascade_candidate_limit);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_candidate_stagnation_epochs" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_candidate_stagnation_epochs</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The number of cascade candidate stagnation epochs determines the number of epochs training is allowed to</p>

<pre>continue without changing the MSE by a fraction of &lt;get_cascade_candidate_change_fraction&gt;.</pre>

          <div class="method-source-code" id="get_cascade_candidate_stagnation_epochs-source">
            <pre>static VALUE get_cascade_candidate_stagnation_epochs(VALUE self)
{
    RETURN_FANN_UINT(fann_get_cascade_candidate_stagnation_epochs);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_max_cand_epochs" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_max_cand_epochs</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The maximum candidate epochs determines the maximum number of epochs the input</p>

<pre>connections to the candidates may be trained before adding a new candidate neuron.</pre>

          <div class="method-source-code" id="get_cascade_max_cand_epochs-source">
            <pre>static VALUE get_cascade_max_cand_epochs(VALUE self)
{
    RETURN_FANN_UINT(fann_get_cascade_max_cand_epochs);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_max_out_epochs" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_max_out_epochs</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The maximum out epochs determines the maximum number of epochs the output connections</p>

<pre>may be trained after adding a new candidate neuron.</pre>

          <div class="method-source-code" id="get_cascade_max_out_epochs-source">
            <pre>static VALUE get_cascade_max_out_epochs(VALUE self)
{
    RETURN_FANN_UINT(fann_get_cascade_max_out_epochs);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_num_candidate_groups" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_num_candidate_groups</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The number of candidate groups is the number of groups of identical candidates which will be used</p>

<pre>during training.</pre>

          <div class="method-source-code" id="get_cascade_num_candidate_groups-source">
            <pre>static VALUE get_cascade_num_candidate_groups(VALUE self)
{
    RETURN_FANN_UINT(fann_get_cascade_num_candidate_groups);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_num_candidates" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_num_candidates</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The number of candidates used during training (calculated by multiplying &lt;get_cascade_activation_functions_count&gt;,</p>

<pre>&lt;get_cascade_activation_steepnesses_count&gt; and &lt;get_cascade_num_candidate_groups&gt;).</pre>

          <div class="method-source-code" id="get_cascade_num_candidates-source">
            <pre>static VALUE get_cascade_num_candidates(VALUE self)
{
    RETURN_FANN_UINT(fann_get_cascade_num_candidates);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_output_change_fraction" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_output_change_fraction</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The cascade output change fraction is a number between 0 and 1</p>

          <div class="method-source-code" id="get_cascade_output_change_fraction-source">
            <pre>static VALUE get_cascade_output_change_fraction(VALUE self)
{
    RETURN_FANN_FLT(fann_get_cascade_output_change_fraction);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_output_stagnation_epochs" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_output_stagnation_epochs</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The number of cascade output stagnation epochs determines the number of epochs training is allowed to</p>

<pre>continue without changing the MSE by a fraction of &lt;get_cascade_output_change_fraction&gt;.</pre>

          <div class="method-source-code" id="get_cascade_output_stagnation_epochs-source">
            <pre>static VALUE get_cascade_output_stagnation_epochs(VALUE self)
{
    RETURN_FANN_INT(fann_get_cascade_output_stagnation_epochs);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_cascade_weight_multiplier" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_cascade_weight_multiplier</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The weight multiplier is a parameter which is used to multiply the weights from the candidate neuron</p>

<pre>before adding the neuron to the neural network. This parameter is usually between 0 and 1, and is used
to make the training a bit less aggressive.</pre>

          <div class="method-source-code" id="get_cascade_weight_multiplier-source">
            <pre>static VALUE get_cascade_weight_multiplier(VALUE self)
{
    RETURN_FANN_DBL(fann_get_cascade_weight_multiplier);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_connection_rate" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_connection_rate</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get the connection rate used when the network was created.</p>

          <div class="method-source-code" id="get_connection_rate-source">
            <pre>static VALUE get_connection_rate(VALUE self)
{
    RETURN_FANN_INT(fann_get_connection_rate);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_layer_array" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_layer_array</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get list of layers in array format where each element contains number of neurons in that layer</p>

          <div class="method-source-code" id="get_layer_array-source">
            <pre>static VALUE get_layer_array(VALUE self)
{
    struct fann *f;
    unsigned int num_layers;
    Data_Get_Struct(self, struct fann, f);
    num_layers = fann_get_num_layers(f);
    unsigned int layers[num_layers];
    fann_get_layer_array(f, layers);

    // Create ruby array &amp; set outputs:
    VALUE arr;
    arr = rb_ary_new();
    unsigned int i;
    for (i = 0; i &lt; num_layers; i++)
    {
        rb_ary_push(arr, INT2NUM(layers[i]));
    }

    return arr;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_learning_momentum" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_learning_momentum</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get the learning momentum.</p>

          <div class="method-source-code" id="get_learning_momentum-source">
            <pre>static VALUE get_learning_momentum(VALUE self)
{
    RETURN_FANN_FLT(fann_get_learning_momentum);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_learning_rate" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_learning_rate</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The learning rate is used to determine how aggressive training should be for some of the</p>

<pre>training algorithms (:incremental, :batch, :quickprop).
Do however note that it is not used in :rprop.
The default learning rate is 0.7.</pre>

          <div class="method-source-code" id="get_learning_rate-source">
            <pre>static VALUE get_learning_rate(VALUE self)
{
    RETURN_FANN_FLT(fann_get_learning_rate);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_network_type" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_network_type</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get the type of network.  Returns as ruby symbol (one of :shortcut, :layer)</p>

          <div class="method-source-code" id="get_network_type-source">
            <pre>static VALUE get_network_type(VALUE self)
{
    struct fann *f;
    enum fann_nettype_enum net_type;
    VALUE ret_val;
    Data_Get_Struct(self, struct fann, f);

    net_type = fann_get_network_type(f);

    if (net_type == FANN_NETTYPE_LAYER)
    {
        ret_val = ID2SYM(rb_intern(&quot;layer&quot;)); // (rb_str_new2(&quot;FANN_NETTYPE_LAYER&quot;));
    }
    else if (net_type == FANN_NETTYPE_SHORTCUT)
    {
        ret_val = ID2SYM(rb_intern(&quot;shortcut&quot;)); // (rb_str_new2(&quot;FANN_NETTYPE_SHORTCUT&quot;));
    }
    return ret_val;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_neurons" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              get_neurons(layer) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Return array&lt;hash&gt; where each array element is a hash representing a neuron.  It contains the following keys:</p>

<pre>  :activation_function, symbol -- the activation function
  :activation_steepness=float -- The steepness of the activation function
  :sum=float -- The sum of the inputs multiplied with the weights
  :value=float -- The value of the activation fuction applied to the sum
  :connections=array&lt;int&gt; -- indices of connected neurons(inputs)

This could be done more elegantly (e.g., defining more ruby ext classes).
  This method does not directly correlate to anything in FANN, and accesses
  structs that are not guaranteed to not change.</pre>

          <div class="method-source-code" id="get_neurons-source">
            <pre>static VALUE get_neurons(VALUE self, VALUE layer)
{
    struct fann_layer *layer_it;
    struct fann_neuron *neuron_it;

    struct fann *f;
    unsigned int i;
    Data_Get_Struct(self, struct fann, f);

    VALUE neuron_array = rb_ary_new();
    VALUE activation_function_sym = ID2SYM(rb_intern(&quot;activation_function&quot;));
    VALUE activation_steepness_sym = ID2SYM(rb_intern(&quot;activation_steepness&quot;));
    VALUE layer_sym = ID2SYM(rb_intern(&quot;layer&quot;));
    VALUE sum_sym = ID2SYM(rb_intern(&quot;sum&quot;));
    VALUE value_sym = ID2SYM(rb_intern(&quot;value&quot;));
    VALUE connections_sym = ID2SYM(rb_intern(&quot;connections&quot;));
    unsigned int layer_num = 0;

    int nuke_bias_neuron = (fann_get_network_type(f) == FANN_NETTYPE_LAYER);
    for (layer_it = f-&gt;first_layer; layer_it != f-&gt;last_layer; layer_it++)
    {
        for (neuron_it = layer_it-&gt;first_neuron; neuron_it != layer_it-&gt;last_neuron; neuron_it++)
        {
            if (nuke_bias_neuron &amp;&amp; (neuron_it == (layer_it-&gt;last_neuron) - 1))
                continue;
            // Create array of connection indicies:
            VALUE connection_array = rb_ary_new();
            for (i = neuron_it-&gt;first_con; i &lt; neuron_it-&gt;last_con; i++)
            {
                rb_ary_push(connection_array, INT2NUM(f-&gt;connections[i] - f-&gt;first_layer-&gt;first_neuron));
            }

            VALUE neuron = rb_hash_new();

            // Set attributes on hash &amp; push on array:
            rb_hash_aset(neuron, activation_function_sym, activation_function_to_sym(neuron_it-&gt;activation_function));
            rb_hash_aset(neuron, activation_steepness_sym, rb_float_new(neuron_it-&gt;activation_steepness));
            rb_hash_aset(neuron, layer_sym, INT2NUM(layer_num));
            rb_hash_aset(neuron, sum_sym, rb_float_new(neuron_it-&gt;sum));
            rb_hash_aset(neuron, value_sym, rb_float_new(neuron_it-&gt;value));
            rb_hash_aset(neuron, connections_sym, connection_array);

            rb_ary_push(neuron_array, neuron);
        }
        ++layer_num;
    }

    // switch (fann_get_network_type(ann)) {
    //     case FANN_NETTYPE_LAYER: {
    //         /* Report one bias in each layer except the last */
    //         if (layer_it != ann-&gt;last_layer-1)
    //             *bias = 1;
    //         else
    //             *bias = 0;
    //         break;
    //     }
    //     case FANN_NETTYPE_SHORTCUT: {

    return neuron_array;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_num_input" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_num_input</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get the number of input neurons.</p>

          <div class="method-source-code" id="get_num_input-source">
            <pre>static VALUE get_num_input(VALUE self)
{
    RETURN_FANN_INT(fann_get_num_input);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_num_layers" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_num_layers</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get the number of layers in the network.</p>

          <div class="method-source-code" id="get_num_layers-source">
            <pre>static VALUE get_num_layers(VALUE self)
{
    RETURN_FANN_INT(fann_get_num_layers);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_num_output" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_num_output</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get the number of output neurons.</p>

          <div class="method-source-code" id="get_num_output-source">
            <pre>static VALUE get_num_output(VALUE self)
{
    RETURN_FANN_INT(fann_get_num_output);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_quickprop_decay" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_quickprop_decay</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The decay is a small negative valued number which is the factor that the weights should become smaller in each iteration during quickprop training. This is used to make sure that the weights do not become too high during training.</p>

          <div class="method-source-code" id="get_quickprop_decay-source">
            <pre>static VALUE get_quickprop_decay(VALUE self)
{
    RETURN_FANN_FLT(fann_get_quickprop_decay);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_quickprop_mu" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_quickprop_mu</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The mu factor is used to increase and decrease the step-size during quickprop training. The mu factor should always be above 1, since it would otherwise decrease the step-size when it was suppose to increase it.</p>

          <div class="method-source-code" id="get_quickprop_mu-source">
            <pre>static VALUE get_quickprop_mu(VALUE self)
{
    RETURN_FANN_FLT(fann_get_quickprop_mu);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_rprop_decrease_factor" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_rprop_decrease_factor</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The decrease factor is a value smaller than 1, which is used to decrease the step-size during RPROP training.</p>

          <div class="method-source-code" id="get_rprop_decrease_factor-source">
            <pre>static VALUE get_rprop_decrease_factor(VALUE self)
{
    RETURN_FANN_FLT(fann_get_rprop_decrease_factor);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_rprop_delta_max" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_rprop_delta_max</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The maximum step-size is a positive number determining how large the maximum step-size may be.</p>

          <div class="method-source-code" id="get_rprop_delta_max-source">
            <pre>static VALUE get_rprop_delta_max(VALUE self)
{
    RETURN_FANN_FLT(fann_get_rprop_delta_max);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_rprop_delta_min" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_rprop_delta_min</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The minimum step-size is a small positive number determining how small the minimum step-size may be.</p>

          <div class="method-source-code" id="get_rprop_delta_min-source">
            <pre>static VALUE get_rprop_delta_min(VALUE self)
{
    RETURN_FANN_FLT(fann_get_rprop_delta_min);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_rprop_delta_zero" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_rprop_delta_zero</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The initial step-size is a positive number determining the initial step size.</p>

          <div class="method-source-code" id="get_rprop_delta_zero-source">
            <pre>static VALUE get_rprop_delta_zero(VALUE self)
{
    RETURN_FANN_FLT(fann_get_rprop_delta_zero);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_rprop_increase_factor" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_rprop_increase_factor</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The increase factor is a value larger than 1, which is used to increase the step-size during RPROP training.</p>

          <div class="method-source-code" id="get_rprop_increase_factor-source">
            <pre>static VALUE get_rprop_increase_factor(VALUE self)
{
    RETURN_FANN_FLT(fann_get_rprop_increase_factor);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_total_connections" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_total_connections</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get the total number of connections in the entire network.</p>

          <div class="method-source-code" id="get_total_connections-source">
            <pre>static VALUE get_total_connections(VALUE self)
{
    RETURN_FANN_INT(fann_get_total_connections);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_total_neurons" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_total_neurons</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Get the total number of neurons in the entire network.</p>

          <div class="method-source-code" id="get_total_neurons-source">
            <pre>static VALUE get_total_neurons(VALUE self)
{
    RETURN_FANN_INT(fann_get_total_neurons);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_train_error_function" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_train_error_function</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the error function used during training.  One of the following symbols:</p>

<pre>:linear, :tanh</pre>

          <div class="method-source-code" id="get_train_error_function-source">
            <pre>static VALUE get_train_error_function(VALUE self)
{
    struct fann *f;
    enum fann_errorfunc_enum train_error;
    VALUE ret_val;
    Data_Get_Struct(self, struct fann, f);

    train_error = fann_get_train_error_function(f);

    if (train_error == FANN_ERRORFUNC_LINEAR)
    {
        ret_val = ID2SYM(rb_intern(&quot;linear&quot;));
    }
    else
    {
        ret_val = ID2SYM(rb_intern(&quot;tanh&quot;));
    }
    return ret_val;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_train_stop_function" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_train_stop_function</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the training stop function.  One of the following symbols:</p>

<pre>:mse, :bit</pre>

          <div class="method-source-code" id="get_train_stop_function-source">
            <pre>static VALUE get_train_stop_function(VALUE self)
{
    struct fann *f;
    enum fann_stopfunc_enum train_stop;
    VALUE ret_val;
    Data_Get_Struct(self, struct fann, f);

    train_stop = fann_get_train_stop_function(f);

    if (train_stop == FANN_STOPFUNC_MSE)
    {
        ret_val = ID2SYM(rb_intern(&quot;mse&quot;)); // (rb_str_new2(&quot;FANN_NETTYPE_LAYER&quot;));
    }
    else // if(train_stop==FANN_STOPFUNC_BIT)
    {
        ret_val = ID2SYM(rb_intern(&quot;bit&quot;)); // (rb_str_new2(&quot;FANN_NETTYPE_SHORTCUT&quot;));
    }
    return ret_val;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-get_training_algorithm" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">get_training_algorithm</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the training algorithm.  One of the following symbols:</p>

<pre>:incremental, :batch, :rprop, :quickprop</pre>

          <div class="method-source-code" id="get_training_algorithm-source">
            <pre>static VALUE get_training_algorithm(VALUE self)
{
    struct fann *f;
    enum fann_train_enum fann_train_algorithm;
    VALUE ret_val;
    Data_Get_Struct(self, struct fann, f);

    fann_train_algorithm = fann_get_training_algorithm(f);

    if (fann_train_algorithm == FANN_TRAIN_INCREMENTAL)
    {
        ret_val = ID2SYM(rb_intern(&quot;incremental&quot;));
    }
    else if (fann_train_algorithm == FANN_TRAIN_BATCH)
    {
        ret_val = ID2SYM(rb_intern(&quot;batch&quot;));
    }
    else if (fann_train_algorithm == FANN_TRAIN_RPROP)
    {
        ret_val = ID2SYM(rb_intern(&quot;rprop&quot;));
    }
    else if (fann_train_algorithm == FANN_TRAIN_QUICKPROP)
    {
        ret_val = ID2SYM(rb_intern(&quot;quickprop&quot;));
    }
    return ret_val;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-init_weights" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              init_weights(train_data) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Initialize the weights using Widrow + Nguyens algorithm.</p>

          <div class="method-source-code" id="init_weights-source">
            <pre>static VALUE init_weights(VALUE self, VALUE train_data)
{

    Check_Type(train_data, T_DATA);

    struct fann *f;
    struct fann_train_data *t;
    Data_Get_Struct(self, struct fann, f);
    Data_Get_Struct(train_data, struct fann_train_data, t);

    fann_init_weights(f, t);
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-print_connections" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">print_connections</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Will print the connections of the ann in a compact matrix,</p>

<pre>for easy viewing of the internals of the ann.</pre>

          <div class="method-source-code" id="print_connections-source">
            <pre>static VALUE print_connections(VALUE self)
{
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_print_connections(f);
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-print_parameters" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">print_parameters</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Print current NN parameters to stdout</p>

          <div class="method-source-code" id="print_parameters-source">
            <pre>static VALUE print_parameters(VALUE self)
{
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_print_parameters(f);
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-randomize_weights" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              randomize_weights(min_weight, max_weight)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Give each connection a random weight between <strong>min_weight</strong> and <strong>max_weight</strong></p>

          <div class="method-source-code" id="randomize_weights-source">
            <pre>static VALUE randomize_weights(VALUE self, VALUE min_weight, VALUE max_weight)
{
    Check_Type(min_weight, T_FLOAT);
    Check_Type(max_weight, T_FLOAT);
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_randomize_weights(f, NUM2DBL(min_weight), NUM2DBL(max_weight));
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-reset_MSE" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">reset_MSE</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Resets the mean square error from the network. This function also resets the number of bits that fail.</p>

          <div class="method-source-code" id="reset_MSE-source">
            <pre>static VALUE reset_MSE(VALUE self)
{
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_reset_MSE(f);
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-run" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              run(inputs) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Run neural net on array&lt;Float&gt; of inputs with current parameters. Returns array&lt;Float&gt; as output </p>

          <div class="method-source-code" id="run-source">
            <pre>static VALUE run(VALUE self, VALUE inputs)
{
    Check_Type(inputs, T_ARRAY);

    struct fann *f;
    unsigned int i;
    fann_type *outputs;

    // Convert inputs to type needed for NN:
    unsigned int len = RARRAY_LEN(inputs);
    fann_type fann_inputs[len];
    for (i = 0; i &lt; len; i++)
    {
        fann_inputs[i] = NUM2DBL(RARRAY_PTR(inputs)[i]);
    }

    // Obtain NN &amp; run method:
    Data_Get_Struct(self, struct fann, f);
    outputs = fann_run(f, fann_inputs);

    // Create ruby array &amp; set outputs:
    VALUE arr;
    arr = rb_ary_new();
    unsigned int output_len = fann_get_num_output(f);
    for (i = 0; i &lt; output_len; i++)
    {
        rb_ary_push(arr, rb_float_new(outputs[i]));
    }

    return arr;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-save" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              save(filename) &rarr; return status
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Save the entire network to configuration file with given name</p>

          <div class="method-source-code" id="save-source">
            <pre>static VALUE nn_save(VALUE self, VALUE filename)
{
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    int status = fann_save(f, StringValuePtr(filename));
    return INT2NUM(status);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_activation_function" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_activation_function(activation_func, layer, neuron)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the activation function for neuron number <strong>neuron</strong> in layer number <strong>layer</strong>,</p>

<pre>counting the input layer as layer 0.  activation_func must be one of the following symbols:
    :linear, :threshold, :threshold_symmetric, :sigmoid, :sigmoid_stepwise, :sigmoid_symmetric,
    :sigmoid_symmetric_stepwise, :gaussian, :gaussian_symmetric, :gaussian_stepwise, :elliot,
    :elliot_symmetric, :linear_piece, :linear_piece_symmetric, :sin_symmetric, :cos_symmetric,
    :sin, :cos</pre>

          <div class="method-source-code" id="set_activation_function-source">
            <pre>static VALUE set_activation_function(VALUE self, VALUE activation_func, VALUE layer, VALUE neuron)
{
    Check_Type(activation_func, T_SYMBOL);
    Check_Type(layer, T_FIXNUM);
    Check_Type(neuron, T_FIXNUM);

    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_set_activation_function(f, sym_to_activation_function(activation_func), NUM2INT(layer), NUM2INT(neuron));
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_activation_function_hidden" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_activation_function_hidden(activation_func)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the activation function for all of the hidden layers.  activation_func must be one of the following symbols:</p>

<pre>:linear, :threshold, :threshold_symmetric, :sigmoid, :sigmoid_stepwise, :sigmoid_symmetric,
:sigmoid_symmetric_stepwise, :gaussian, :gaussian_symmetric, :gaussian_stepwise, :elliot,
:elliot_symmetric, :linear_piece, :linear_piece_symmetric, :sin_symmetric, :cos_symmetric,
:sin, :cos</pre>

          <div class="method-source-code" id="set_activation_function_hidden-source">
            <pre>static VALUE set_activation_function_hidden(VALUE self, VALUE activation_func)
{
    Check_Type(activation_func, T_SYMBOL);
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_set_activation_function_hidden(f, sym_to_activation_function(activation_func));
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_activation_function_layer" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_activation_function_layer(activation_func, layer)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the activation function for all the neurons in the layer number <strong>layer</strong>,</p>

<pre>  counting the input layer as layer 0.  activation_func must be one of the following symbols:
      :linear, :threshold, :threshold_symmetric, :sigmoid, :sigmoid_stepwise, :sigmoid_symmetric,
      :sigmoid_symmetric_stepwise, :gaussian, :gaussian_symmetric, :gaussian_stepwise, :elliot,
      :elliot_symmetric, :linear_piece, :linear_piece_symmetric, :sin_symmetric, :cos_symmetric,
      :sin, :cos

It is not possible to set activation functions for the neurons in the input layer.</pre>

          <div class="method-source-code" id="set_activation_function_layer-source">
            <pre>static VALUE set_activation_function_layer(VALUE self, VALUE activation_func, VALUE layer)
{
    Check_Type(activation_func, T_SYMBOL);
    Check_Type(layer, T_FIXNUM);
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_set_activation_function_layer(f, sym_to_activation_function(activation_func), NUM2INT(layer));
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_activation_function_output" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_activation_function_output(activation_func)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the activation function for the output layer.  activation_func must be one of the following symbols:</p>

<pre>:linear, :threshold, :threshold_symmetric, :sigmoid, :sigmoid_stepwise, :sigmoid_symmetric,
:sigmoid_symmetric_stepwise, :gaussian, :gaussian_symmetric, :gaussian_stepwise, :elliot,
:elliot_symmetric, :linear_piece, :linear_piece_symmetric, :sin_symmetric, :cos_symmetric,
:sin, :cos</pre>

          <div class="method-source-code" id="set_activation_function_output-source">
            <pre>static VALUE set_activation_function_output(VALUE self, VALUE activation_func)
{
    Check_Type(activation_func, T_SYMBOL);
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_set_activation_function_output(f, sym_to_activation_function(activation_func));
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_activation_steepness" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_activation_steepness(steepness, layer, neuron)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the activation steepness for neuron number {neuron} in layer number {layer}, counting the input layer as layer 0.</p>

          <div class="method-source-code" id="set_activation_steepness-source">
            <pre>static VALUE set_activation_steepness(VALUE self, VALUE steepness, VALUE layer, VALUE neuron)
{
    Check_Type(steepness, T_FLOAT);
    Check_Type(layer, T_FIXNUM);
    Check_Type(neuron, T_FIXNUM);

    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_set_activation_steepness(f, NUM2DBL(steepness), NUM2INT(layer), NUM2INT(neuron));
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_activation_steepness_hidden" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_activation_steepness_hidden(arg) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the activation steepness in all of the hidden layers.</p>

          <div class="method-source-code" id="set_activation_steepness_hidden-source">
            <pre>static VALUE set_activation_steepness_hidden(VALUE self, VALUE steepness)
{
    SET_FANN_FLT(steepness, fann_set_activation_steepness_hidden);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_activation_steepness_layer" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_activation_steepness_layer(steepness, layer)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the activation steepness all of the neurons in layer number <strong>layer</strong>, counting the input layer as layer 0.</p>

          <div class="method-source-code" id="set_activation_steepness_layer-source">
            <pre>static VALUE set_activation_steepness_layer(VALUE self, VALUE steepness, VALUE layer)
{
    Check_Type(steepness, T_FLOAT);
    Check_Type(layer, T_FIXNUM);

    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_set_activation_steepness_layer(f, NUM2DBL(steepness), NUM2INT(layer));
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_activation_steepness_output" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_activation_steepness_output(steepness)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the activation steepness in the output layer.</p>

          <div class="method-source-code" id="set_activation_steepness_output-source">
            <pre>static VALUE set_activation_steepness_output(VALUE self, VALUE steepness)
{
    SET_FANN_FLT(steepness, fann_set_activation_steepness_output);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_bit_fail_limit" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_bit_fail_limit(bit_fail_limit)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Sets the bit fail limit used during training.</p>

          <div class="method-source-code" id="set_bit_fail_limit-source">
            <pre>static VALUE set_bit_fail_limit(VALUE self, VALUE bit_fail_limit)
{
    SET_FANN_FLT(bit_fail_limit, fann_set_bit_fail_limit);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_activation_functions" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_cascade_activation_functions(cascade_activation_functions)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The cascade activation functions is an array of the different activation functions used by</p>

<pre class="ruby"><span class="ruby-identifier">the</span> <span class="ruby-identifier">candidates</span>.  <span class="ruby-constant">The</span> <span class="ruby-identifier">default</span> <span class="ruby-identifier">is</span> [<span class="ruby-value">:sigmoid</span>, <span class="ruby-value">:sigmoid_symmetric</span>, <span class="ruby-value">:gaussian</span>, <span class="ruby-value">:gaussian_symmetric</span>, <span class="ruby-value">:elliot</span>, <span class="ruby-value">:elliot_symmetric</span>]
</pre>

          <div class="method-source-code" id="set_cascade_activation_functions-source">
            <pre>static VALUE set_cascade_activation_functions(VALUE self, VALUE cascade_activation_functions)
{
    Check_Type(cascade_activation_functions, T_ARRAY);
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);

    unsigned long cnt = RARRAY_LEN(cascade_activation_functions);
    enum fann_activationfunc_enum fann_activation_functions[cnt];
    unsigned int i;
    for (i = 0; i &lt; cnt; i++)
    {
        fann_activation_functions[i] = sym_to_activation_function(RARRAY_PTR(cascade_activation_functions)[i]);
    }

    fann_set_cascade_activation_functions(f, fann_activation_functions, cnt);
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_activation_steepnesses" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">set_cascade_activation_steepnesses</span><span
              class="method-args">(p1)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The cascade activation steepnesses array is an array of the different activation functions used by</p>

<pre>the candidates.</pre>

          <div class="method-source-code" id="set_cascade_activation_steepnesses-source">
            <pre>static VALUE set_cascade_activation_steepnesses(VALUE self, VALUE cascade_activation_steepnesses)
{
    Check_Type(cascade_activation_steepnesses, T_ARRAY);
    struct fann *f;
    Data_Get_Struct(self, struct fann, f);

    unsigned int cnt = RARRAY_LEN(cascade_activation_steepnesses);
    fann_type fann_activation_steepnesses[cnt];
    unsigned int i;
    for (i = 0; i &lt; cnt; i++)
    {
        fann_activation_steepnesses[i] = NUM2DBL(RARRAY_PTR(cascade_activation_steepnesses)[i]);
    }

    fann_set_cascade_activation_steepnesses(f, fann_activation_steepnesses, cnt);
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_candidate_change_fraction" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_cascade_candidate_change_fraction(cascade_candidate_change_fraction)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The cascade candidate change fraction is a number between 0 and 1</p>

          <div class="method-source-code" id="set_cascade_candidate_change_fraction-source">
            <pre>static VALUE set_cascade_candidate_change_fraction(VALUE self, VALUE cascade_candidate_change_fraction)
{
    SET_FANN_FLT(cascade_candidate_change_fraction, fann_set_cascade_candidate_change_fraction);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_candidate_limit" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_cascade_candidate_limit(cascade_candidate_limit)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The candidate limit is a limit for how much the candidate neuron may be trained.</p>

<pre>The limit is a limit on the proportion between the MSE and candidate score.</pre>

          <div class="method-source-code" id="set_cascade_candidate_limit-source">
            <pre>static VALUE set_cascade_candidate_limit(VALUE self, VALUE cascade_candidate_limit)
{
    SET_FANN_DBL(cascade_candidate_limit, fann_set_cascade_candidate_limit);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_candidate_stagnation_epochs" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_cascade_candidate_stagnation_epochs(cascade_candidate_stagnation_epochs)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The number of cascade candidate stagnation epochs determines the number of epochs training is allowed to</p>

<pre>continue without changing the MSE by a fraction of &lt;get_cascade_candidate_change_fraction&gt;.</pre>

          <div class="method-source-code" id="set_cascade_candidate_stagnation_epochs-source">
            <pre>static VALUE set_cascade_candidate_stagnation_epochs(VALUE self, VALUE cascade_candidate_stagnation_epochs)
{
    SET_FANN_UINT(cascade_candidate_stagnation_epochs, fann_set_cascade_candidate_stagnation_epochs);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_max_cand_epochs" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_cascade_max_cand_epochs(cascade_max_cand_epochs)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The maximum candidate epochs determines the maximum number of epochs the input</p>

<pre>connections to the candidates may be trained before adding a new candidate neuron.</pre>

          <div class="method-source-code" id="set_cascade_max_cand_epochs-source">
            <pre>static VALUE set_cascade_max_cand_epochs(VALUE self, VALUE cascade_max_cand_epochs)
{
    SET_FANN_UINT(cascade_max_cand_epochs, fann_set_cascade_max_cand_epochs);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_max_out_epochs" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_cascade_max_out_epochs(cascade_max_out_epochs)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The maximum out epochs determines the maximum number of epochs the output connections</p>

<pre>may be trained after adding a new candidate neuron.</pre>

          <div class="method-source-code" id="set_cascade_max_out_epochs-source">
            <pre>static VALUE set_cascade_max_out_epochs(VALUE self, VALUE cascade_max_out_epochs)
{
    SET_FANN_UINT(cascade_max_out_epochs, fann_set_cascade_max_out_epochs);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_num_candidate_groups" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_cascade_num_candidate_groups(cascade_num_candidate_groups)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The number of candidate groups is the number of groups of identical candidates which will be used</p>

<pre>during training.</pre>

          <div class="method-source-code" id="set_cascade_num_candidate_groups-source">
            <pre>static VALUE set_cascade_num_candidate_groups(VALUE self, VALUE cascade_num_candidate_groups)
{
    SET_FANN_UINT(cascade_num_candidate_groups, fann_set_cascade_num_candidate_groups);
    return 0;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_output_change_fraction" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_cascade_output_change_fraction(cascade_output_change_fraction)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The cascade output change fraction is a number between 0 and 1</p>

          <div class="method-source-code" id="set_cascade_output_change_fraction-source">
            <pre>static VALUE set_cascade_output_change_fraction(VALUE self, VALUE cascade_output_change_fraction)
{
    SET_FANN_FLT(cascade_output_change_fraction, fann_set_cascade_output_change_fraction);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_output_stagnation_epochs" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_cascade_output_stagnation_epochs(cascade_output_stagnation_epochs)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The number of cascade output stagnation epochs determines the number of epochs training is allowed to</p>

<pre>continue without changing the MSE by a fraction of &lt;get_cascade_output_change_fraction&gt;.</pre>

          <div class="method-source-code" id="set_cascade_output_stagnation_epochs-source">
            <pre>static VALUE set_cascade_output_stagnation_epochs(VALUE self, VALUE cascade_output_stagnation_epochs)
{
    SET_FANN_INT(cascade_output_stagnation_epochs, fann_set_cascade_output_stagnation_epochs);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_cascade_weight_multiplier" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_cascade_weight_multiplier(cascade_weight_multiplier)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The weight multiplier is a parameter which is used to multiply the weights from the candidate neuron</p>

<pre>before adding the neuron to the neural network. This parameter is usually between 0 and 1, and is used
to make the training a bit less aggressive.</pre>

          <div class="method-source-code" id="set_cascade_weight_multiplier-source">
            <pre>static VALUE set_cascade_weight_multiplier(VALUE self, VALUE cascade_weight_multiplier)
{
    SET_FANN_DBL(cascade_weight_multiplier, fann_set_cascade_weight_multiplier);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_learning_momentum" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_learning_momentum(learning_momentum) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the learning momentum.</p>

          <div class="method-source-code" id="set_learning_momentum-source">
            <pre>static VALUE set_learning_momentum(VALUE self, VALUE learning_momentum)
{
    SET_FANN_FLT(learning_momentum, fann_set_learning_momentum);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_learning_rate" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_learning_rate(learning_rate) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The learning rate is used to determine how aggressive training should be for some of the</p>

<pre>training algorithms (:incremental, :batch, :quickprop).
Do however note that it is not used in :rprop.
The default learning rate is 0.7.</pre>

          <div class="method-source-code" id="set_learning_rate-source">
            <pre>static VALUE set_learning_rate(VALUE self, VALUE learning_rate)
{
    SET_FANN_FLT(learning_rate, fann_set_learning_rate);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_quickprop_decay" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_quickprop_decay(quickprop_decay)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Sets the quickprop decay factor</p>

          <div class="method-source-code" id="set_quickprop_decay-source">
            <pre>static VALUE set_quickprop_decay(VALUE self, VALUE quickprop_decay)
{
    SET_FANN_FLT(quickprop_decay, fann_set_quickprop_decay);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_quickprop_mu" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_quickprop_mu(quickprop_mu)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Sets the quickprop mu factor.</p>

          <div class="method-source-code" id="set_quickprop_mu-source">
            <pre>static VALUE set_quickprop_mu(VALUE self, VALUE quickprop_mu)
{
    SET_FANN_FLT(quickprop_mu, fann_set_quickprop_mu);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_rprop_decrease_factor" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_rprop_decrease_factor(rprop_decrease_factor)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The decrease factor is a value smaller than 1, which is used to decrease the step-size during RPROP training.</p>

          <div class="method-source-code" id="set_rprop_decrease_factor-source">
            <pre>static VALUE set_rprop_decrease_factor(VALUE self, VALUE rprop_decrease_factor)
{
    SET_FANN_FLT(rprop_decrease_factor, fann_set_rprop_decrease_factor);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_rprop_delta_max" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_rprop_delta_max(rprop_delta_max)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The maximum step-size is a positive number determining how large the maximum step-size may be.</p>

          <div class="method-source-code" id="set_rprop_delta_max-source">
            <pre>static VALUE set_rprop_delta_max(VALUE self, VALUE rprop_delta_max)
{
    SET_FANN_FLT(rprop_delta_max, fann_set_rprop_delta_max);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_rprop_delta_min" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_rprop_delta_min(rprop_delta_min)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The minimum step-size is a small positive number determining how small the minimum step-size may be.</p>

          <div class="method-source-code" id="set_rprop_delta_min-source">
            <pre>static VALUE set_rprop_delta_min(VALUE self, VALUE rprop_delta_min)
{
    SET_FANN_FLT(rprop_delta_min, fann_set_rprop_delta_min);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_rprop_delta_zero" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_rprop_delta_zero(rprop_delta_zero)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The initial step-size is a positive number determining the initial step size.</p>

          <div class="method-source-code" id="set_rprop_delta_zero-source">
            <pre>static VALUE set_rprop_delta_zero(VALUE self, VALUE rprop_delta_zero)
{
    SET_FANN_FLT(rprop_delta_zero, fann_set_rprop_delta_zero);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_rprop_increase_factor" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_rprop_increase_factor(rprop_increase_factor)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>The increase factor used during RPROP training.</p>

          <div class="method-source-code" id="set_rprop_increase_factor-source">
            <pre>static VALUE set_rprop_increase_factor(VALUE self, VALUE rprop_increase_factor)
{
    SET_FANN_FLT(rprop_increase_factor, fann_set_rprop_increase_factor);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_train_error_function" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_train_error_function(train_error_function)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Sets the error function used during training.  One of the following symbols:</p>

<pre>:linear, :tanh</pre>

          <div class="method-source-code" id="set_train_error_function-source">
            <pre>static VALUE set_train_error_function(VALUE self, VALUE train_error_function)
{
    Check_Type(train_error_function, T_SYMBOL);

    ID id = SYM2ID(train_error_function);
    enum fann_errorfunc_enum fann_train_error_function;

    if (id == rb_intern(&quot;linear&quot;))
    {
        fann_train_error_function = FANN_ERRORFUNC_LINEAR;
    }
    else if (id == rb_intern(&quot;tanh&quot;))
    {
        fann_train_error_function = FANN_ERRORFUNC_TANH;
    }
    else
    {
        rb_raise(rb_eRuntimeError, &quot;Unrecognized train error function: [%s]&quot;, rb_id2name(SYM2ID(train_error_function)));
    }

    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_set_train_error_function(f, fann_train_error_function);
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_train_stop_function" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_train_stop_function(train_stop_function) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the training stop function.  One of the following symbols:</p>

<pre>:mse, :bit</pre>

          <div class="method-source-code" id="set_train_stop_function-source">
            <pre>static VALUE set_train_stop_function(VALUE self, VALUE train_stop_function)
{
    Check_Type(train_stop_function, T_SYMBOL);
    ID id = SYM2ID(train_stop_function);
    enum fann_stopfunc_enum fann_train_stop_function;

    if (id == rb_intern(&quot;mse&quot;))
    {
        fann_train_stop_function = FANN_STOPFUNC_MSE;
    }
    else if (id == rb_intern(&quot;bit&quot;))
    {
        fann_train_stop_function = FANN_STOPFUNC_BIT;
    }
    else
    {
        rb_raise(rb_eRuntimeError, &quot;Unrecognized stop function: [%s]&quot;, rb_id2name(SYM2ID(train_stop_function)));
    }

    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_set_train_stop_function(f, fann_train_stop_function);
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-set_training_algorithm" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              set_training_algorithm(train_error_function)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Set the training algorithm.  One of the following symbols:</p>

<pre>:incremental, :batch, :rprop, :quickprop</pre>

          <div class="method-source-code" id="set_training_algorithm-source">
            <pre>static VALUE set_training_algorithm(VALUE self, VALUE train_error_function)
{
    Check_Type(train_error_function, T_SYMBOL);

    ID id = SYM2ID(train_error_function);
    enum fann_train_enum fann_train_algorithm;

    if (id == rb_intern(&quot;incremental&quot;))
    {
        fann_train_algorithm = FANN_TRAIN_INCREMENTAL;
    }
    else if (id == rb_intern(&quot;batch&quot;))
    {
        fann_train_algorithm = FANN_TRAIN_BATCH;
    }
    else if (id == rb_intern(&quot;rprop&quot;))
    {
        fann_train_algorithm = FANN_TRAIN_RPROP;
    }
    else if (id == rb_intern(&quot;quickprop&quot;))
    {
        fann_train_algorithm = FANN_TRAIN_QUICKPROP;
    }
    else
    {
        rb_raise(rb_eRuntimeError, &quot;Unrecognized training algorithm function: [%s]&quot;, rb_id2name(SYM2ID(train_error_function)));
    }

    struct fann *f;
    Data_Get_Struct(self, struct fann, f);
    fann_set_training_algorithm(f, fann_train_algorithm);
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-test_data" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              test_data(train_data) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Test a set of training data and calculates the MSE for the training data.</p>

          <div class="method-source-code" id="test_data-source">
            <pre>static VALUE test_data(VALUE self, VALUE train_data)
{
    Check_Type(train_data, T_DATA);
    struct fann *f;
    struct fann_train_data *t;
    Data_Get_Struct(self, struct fann, f);
    Data_Get_Struct(train_data, struct fann_train_data, t);
    return rb_float_new(fann_test_data(f, t));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-train" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              train(input, expected_output)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Train with a single input-output pair.</p>

<pre>input - The inputs given to the network
expected_output - The outputs expected.</pre>

          <div class="method-source-code" id="train-source">
            <pre>static VALUE train(VALUE self, VALUE input, VALUE expected_output)
{
    Check_Type(input, T_ARRAY);
    Check_Type(expected_output, T_ARRAY);

    struct fann *f;
    Data_Get_Struct(self, struct fann, f);

    unsigned int num_input = RARRAY_LEN(input);
    unsigned int num_output = RARRAY_LEN(expected_output);

    fann_type data_input[num_input], data_output[num_output];

    unsigned int i;

    for (i = 0; i &lt; num_input; i++)
    {
        data_input[i] = NUM2DBL(RARRAY_PTR(input)[i]);
    }

    for (i = 0; i &lt; num_output; i++)
    {
        data_output[i] = NUM2DBL(RARRAY_PTR(expected_output)[i]);
    }

    fann_train(f, data_input, data_output);

    return rb_int_new(0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-train_epoch" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              train_epoch(train_data) &rarr; return value
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Train one epoch with a set of training data, created with <a href="TrainData.html#method-c-new"><code>RubyFann::TrainData.new</code></a></p>

          <div class="method-source-code" id="train_epoch-source">
            <pre>static VALUE train_epoch(VALUE self, VALUE train_data)
{
    Check_Type(train_data, T_DATA);
    struct fann *f;
    struct fann_train_data *t;
    Data_Get_Struct(self, struct fann, f);
    Data_Get_Struct(train_data, struct fann_train_data, t);
    return rb_float_new(fann_train_epoch(f, t));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-train_on_data" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              train_on_data(train_data, max_epochs, epochs_between_reports, desired_error)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Train with training data created with <a href="TrainData.html#method-c-new"><code>RubyFann::TrainData.new</code></a></p>

<pre>max_epochs - The maximum number of epochs the training should continue
epochs_between_reports - The number of epochs between printing a status report to stdout.
desired_error - The desired &lt;get_MSE&gt; or &lt;get_bit_fail&gt;, depending on which stop function
    is chosen by &lt;set_train_stop_function&gt;.</pre>

          <div class="method-source-code" id="train_on_data-source">
            <pre>static VALUE train_on_data(VALUE self, VALUE train_data, VALUE max_epochs, VALUE epochs_between_reports, VALUE desired_error)
{
    Check_Type(train_data, T_DATA);
    Check_Type(max_epochs, T_FIXNUM);
    Check_Type(epochs_between_reports, T_FIXNUM);
    Check_Type(desired_error, T_FLOAT);

    struct fann *f;
    struct fann_train_data *t;
    Data_Get_Struct(self, struct fann, f);
    Data_Get_Struct(train_data, struct fann_train_data, t);

    unsigned int fann_max_epochs = NUM2INT(max_epochs);
    unsigned int fann_epochs_between_reports = NUM2INT(epochs_between_reports);
    float fann_desired_error = NUM2DBL(desired_error);
    fann_train_on_data(f, t, fann_max_epochs, fann_epochs_between_reports, fann_desired_error);
    return rb_int_new(0);
}</pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.5.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

